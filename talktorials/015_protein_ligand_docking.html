
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#2196f3">
  <script src="../_static/javascripts/modernizr.js"></script>
  
  
    <link rel="apple-touch-icon" href="../_static/images/apple-icon-152x152.png"/>
  
  
    <title>Structure-based CADD using online APIs/servers &#8212; TeachOpenCADD 0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/material.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Structure-based CADD using online APIs/servers" href="016_protein_ligand_interactions.html" />
    <link rel="prev" title="Structure-based CADD using online APIs/servers" href="012_query_pubchem.html" />
  
    <link rel="apple-touch-icon" href="../_static/images/apple-icon-152x152.png"/>
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=teal data-md-color-accent=cyan>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#talktorials/015_protein_ligand_docking" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../index.html" title="TeachOpenCADD 0 documentation"
           class="md-header-nav__button md-logo">
          
            <i class="md-icon">school</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">TeachOpenCADD (WIP 🚧)</span>
          <span class="md-header-nav__topic"> Structure-based CADD using online APIs/servers </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/volkamerlab/teachopencadd/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    TeachOpenCADD
  </div>
</a>
          </div>
        </div>
      
      
    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
            
            <li class="md-tabs__item"><a href="../talktorials.html" class="md-tabs__link">Our talktorials</a></li>
            
            <li class="md-tabs__item"><a href="../installing.html" class="md-tabs__link">Run locally</a></li>
            
            <li class="md-tabs__item"><a href="../contribute.html" class="md-tabs__link">Contribute</a></li>
          <li class="md-tabs__item"><a href="../talktorials.html" class="md-tabs__link">Talktorials by collection</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../index.html" title="TeachOpenCADD 0 documentation" class="md-nav__button md-logo">
      
        <i class="md-icon">school</i>
      
    </a>
    <a href="../index.html"
       title="TeachOpenCADD 0 documentation">TeachOpenCADD (WIP 🚧)</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/volkamerlab/teachopencadd/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    TeachOpenCADD
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">Our talktorials</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../talktorials.html" class="md-nav__link">Talktorials by collection</a>
      <ul class="md-nav__list"> 
    <li class="md-nav__item">
    
    
      <a href="../talktorials.html#jcim-2019" class="md-nav__link">JCIM 2019</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../talktorials.html#online-apis" class="md-nav__link">Online APIs</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../talktorials.html#structural-modeling" class="md-nav__link">Structural modeling</a>
      
    
    </li></ul>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../all_talktorials.html" class="md-nav__link">Complete list of talktorials</a>
      
    
    </li>
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">Run locally</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../installing.html" class="md-nav__link">Installing</a>
      
    
    </li>
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">Contributors</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../contribute.html" class="md-nav__link">For contributors</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../api.html" class="md-nav__link">API Documentation</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#talktorials-015-protein-ligand-docking--page-root" class="md-nav__link">Structure-based CADD using online APIs/servers</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#Aim-of-this-talktorial" class="md-nav__link">Aim of this talktorial</a>
        </li>
        <li class="md-nav__item"><a href="#Learning-goals" class="md-nav__link">Learning goals</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#Theory" class="md-nav__link">Theory</a>
        </li>
        <li class="md-nav__item"><a href="#Practical" class="md-nav__link">Practical</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#References" class="md-nav__link">References</a>
        </li>
        <li class="md-nav__item"><a href="#id1" class="md-nav__link">Theory</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#Molecular-docking" class="md-nav__link">Molecular docking</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#Examples-of-existing-software" class="md-nav__link">Examples of existing software</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#Known-limitations" class="md-nav__link">Known limitations</a>
        </li>
        <li class="md-nav__item"><a href="#Preparation-of-structures" class="md-nav__link">Preparation of structures</a>
        </li>
        <li class="md-nav__item"><a href="#Binding-pocket-prediction" class="md-nav__link">Binding pocket prediction</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#Proteins.plus-DoGSiteScorer" class="md-nav__link">Proteins.plus DoGSiteScorer</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#Docking" class="md-nav__link">Docking</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#SwissDock" class="md-nav__link">SwissDock</a>
        </li>
        <li class="md-nav__item"><a href="#OPAL-webservices" class="md-nav__link">OPAL webservices</a>
        </li></ul>
            </nav>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#Practice" class="md-nav__link">Practice</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#Get-files-from-part-A" class="md-nav__link">Get files from part A</a>
        </li>
        <li class="md-nav__item"><a href="#Use-SwissDock" class="md-nav__link">Use SwissDock</a>
        </li>
        <li class="md-nav__item"><a href="#Perform-docking-with-OPAL-webservices" class="md-nav__link">Perform docking with OPAL webservices</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#Prepare-the-structures" class="md-nav__link">Prepare the structures</a>
        </li>
        <li class="md-nav__item"><a href="#Guess-the-binding-sites" class="md-nav__link">Guess the binding sites</a>
        </li>
        <li class="md-nav__item"><a href="#Run-Vina-on-OPAL" class="md-nav__link">Run Vina on OPAL</a>
        </li>
        <li class="md-nav__item"><a href="#Put-it-all-together" class="md-nav__link">Put it all together</a>
        </li>
        <li class="md-nav__item"><a href="#Understanding-the-output" class="md-nav__link">Understanding the output</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#Visualize-docking-results" class="md-nav__link">Visualize docking results</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#Discussion" class="md-nav__link">Discussion</a>
        </li>
        <li class="md-nav__item"><a href="#Quiz" class="md-nav__link">Quiz</a>
        </li></ul>
            </nav>
        </li>
    
<li class="md-nav__item"><a class="md-nav__extra_link" href="../_sources/talktorials/015_protein_ligand_docking.nblink.txt">Show Source</a> </li>

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container,
div.nbinput.container div.prompt,
div.nbinput.container div.input_area,
div.nbinput.container div[class*=highlight],
div.nbinput.container div[class*=highlight] pre,
div.nboutput.container,
div.nboutput.container div.prompt,
div.nboutput.container div.output_area,
div.nboutput.container div[class*=highlight],
div.nboutput.container div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    background: #f5f5f5;
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
</style>

<h1 id="talktorials-015-protein-ligand-docking--page-root">Structure-based CADD using online APIs/servers<a class="headerlink" href="#talktorials-015-protein-ligand-docking--page-root" title="Permalink to this headline">¶</a></h1>
<p>Authors: - Jaime Rodríguez-Guerra, Volkamer lab, Charité - Dominique Sydow, Volkamer lab, Charité</p>

<h2 id="Aim-of-this-talktorial">Aim of this talktorial<a class="headerlink" href="#Aim-of-this-talktorial" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This is part B of the “Online webservices” talktorial:</p>
<ul class="simple">
<li><p>11a. Querying KLIFS &amp; PubChem for potential kinase inhibitors</p></li>
<li><p><strong>11b. Docking the candidates against the target obtained in 11a</strong></p></li>
<li><p>11c. Assessing the results and comparing against known data</p></li>
</ul>
</div></blockquote>
<p>After obtaining input structures we will use molecular docking software to find good protein-ligand poses.</p>


<h2 id="Learning-goals">Learning goals<a class="headerlink" href="#Learning-goals" title="Permalink to this headline">¶</a></h2>

<h3 id="Theory">Theory<a class="headerlink" href="#Theory" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Molecular docking basics</p></li>
<li><p>Available software</p></li>
<li><p>Known limitations</p></li>
</ul>


<h3 id="Practical">Practical<a class="headerlink" href="#Practical" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Prepare the structures</p></li>
<li><p>Guess the binding site</p></li>
<li><p>Run the docking calculation</p></li>
<li><p>Save the results</p></li>
</ul>



<h2 id="References">References<a class="headerlink" href="#References" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Chapter on Structure‐Based Virtual Screening, <a class="reference external" href="https://onlinelibrary.wiley.com/doi/book/10.1002/9783527806539">Ch. 6.8 in “Applied Chemoinformatics: Achievements and Future Opportunities” (2018)</a></p></li>
<li><p>How to benchmark docking software (<a class="reference external" href="https://pubs.acs.org/doi/abs/10.1021/jm0608356">J. Med. Chem. (2006), 49, 23, 6789–6801</a>)</p></li>
<li><p>A review on molecular docking software (<a class="reference external" href="https://www.ncbi.nlm.nih.gov/pubmed/28510083">Biophysical Reviews (2017), 9, 2, 91–102</a>)</p></li>
<li><p>DoGSiteScorer, a program to identify binding sites.</p>
<ul>
<li><p><a class="reference external" href="https://doi.org/10.1021/ci100241y">J. Chem. Inf. Model. (2010), 50, 11, 2041-2052</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1093/bioinformatics/bts310">Bioinformatics (2012), 28, 15, 2074–2075</a></p></li>
</ul>
</li>
<li><p>SwissDock, a docking program.</p>
<ul>
<li><p><a class="reference external" href="https://academic.oup.com/nar/article/39/suppl_2/W270/2506492">Nucleic Acids Res. (2011), 39, W270-7.</a></p></li>
<li><p><a class="reference external" href="https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.21797">J Comput Chem. (2011), 32, 10, 2149-59</a></p></li>
</ul>
</li>
<li><p>OPAL webservices, which can run software remotely on demand</p>
<ul>
<li><p>Manuscript: <a class="reference external" href="https://academic.oup.com/nar/article/38/suppl_2/W724/1122840">Nucleic Acids Res. (2010), 38, W724-31</a></p></li>
<li><p>Documentation: <a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.533.7960&amp;rep=rep1&amp;type=pdf">Opal: Simple Web Services Wrappers for Scientific Applications</a></p></li>
</ul>
</li>
<li><p>AutoDock Vina, a docking program (<a class="reference external" href="https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.21334">J Comput Chem. (2010), 31, 455–461</a>)</p></li>
</ul>
<hr class="docutils"/>


<h2 id="id1">Theory<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>

<h3 id="Molecular-docking">Molecular docking<a class="headerlink" href="#Molecular-docking" title="Permalink to this headline">¶</a></h3>
<p>Adapted from <a class="reference external" href="https://link.springer.com/article/10.1007%2Fs12551-016-0247-1">Pagadala, Syed &amp; Tuszynski, Biophysical Reviews 2017, 9, 2, 91–102</a>:</p>
<blockquote>
<div><p>Molecular docking methodology explores the behavior of small molecules in the binding site of a target protein. The applied software performs a search algorithm in which the conformation of the ligand is evaluated recursively until the convergence to the minimum energy is reached. Finally, an affinity scoring function, ΔG (U total in kcal/mol), is employed to rank the candidate poses as the sum of the electrostatic and van der Waals energies. The driving forces for these specific interactions
in biological systems aim toward complementarities between the shape and electrostatics of the binding site surfaces and the ligand or substrate.</p>
</div></blockquote>
<p>These scoring functions are tailored to be fast to compute, and thus their accuracy is often poorer than in other molecular modeling methods. Normally, they are based on:</p>
<ul class="simple">
<li><p>Molecular mechanics principles</p></li>
<li><p>Knowledge-based potentials</p></li>
<li><p>Shape and geometric complementarity</p></li>
</ul>
<p>To reduce the search space dimensionality, some approximations are often applied:</p>
<ul class="simple">
<li><p>The protein structure is considered mostly rigid, with maybe some side chains in the vicinities of the search area allowed to explore a limited set of conformations (rotamers).</p></li>
<li><p>The ligand can be considered rigid in virtual screening studies, but it is often allowed to freely explore its bond torsions in more detailed calculations. A compromise between both options is defining a set of probable conformations beforehand.</p></li>
</ul>

<h4 id="Examples-of-existing-software">Examples of existing software<a class="headerlink" href="#Examples-of-existing-software" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Commercial</p>
<ul>
<li><p>GOLD</p></li>
<li><p>Schrödinger</p></li>
<li><p>FlexX</p></li>
</ul>
</li>
<li><p>Free (or free for academics)</p>
<ul>
<li><p>AutoDock</p></li>
<li><p>AutoDock Vina</p></li>
<li><p>DOCK</p></li>
<li><p>OpenEye</p></li>
</ul>
</li>
</ul>



<h3 id="Known-limitations">Known limitations<a class="headerlink" href="#Known-limitations" title="Permalink to this headline">¶</a></h3>
<p>The following approximations could introduce artifacts in the calculation.</p>
<ul class="simple">
<li><p>Since the protein is mostly rigid, the dynamic, adaptive nature of the protein-ligand binding is barely explored. This can result in some false positives: even if the ligand finds a suitable pose in the binding pocket, this position is not guaranteed until the protein is allowed to explore near-minima conformations. In other words, short molecular dynamics trajectories are always recommended to check that the ligand stays in the binding pocket.</p></li>
<li><p>The scoring function must be cheap to resolve. While the accuracy is good enough to distinguish good poses from bad poses, it can have problems sorting the best poses. For example, while most popular docking programs are able to find the experimental pose in their calculations, this pose is rarely the best one of the proposed set.</p></li>
<li><p>To reduce the computational cost, docking procedures are only performed in a subset of the protein (normally around a known binding pocket). Choosing the correct binding pocket becomes then another question in the CADD pipeline.</p></li>
<li><p>To leverage the accuracy of the calculation, the structures must be reduced accordingly. Protonation states of amino acids and the ligands can be tricky to get right, especially in the case of (potential) tautomers. This introduces yet another cause to obtain wrong results.</p></li>
</ul>
<p>Despite all these limitations, docking calculations are still popularly used in all pharma laboratories, along with other types of molecular simulation. In this part of the talktorial we will learn how to:</p>
<ol class="arabic simple">
<li><p>Prepare the protein and ligands obtained in part A (locally)</p></li>
<li><p>Estimate the most probable binding pocket (online)</p></li>
<li><p>Run the docking calculations (online)</p></li>
</ol>
<hr class="docutils"/>


<h3 id="Preparation-of-structures">Preparation of structures<a class="headerlink" href="#Preparation-of-structures" title="Permalink to this headline">¶</a></h3>
<p>We will use the AutoDock Vina installation present in the OPAL webservices. However, this requires preparing the structures beforehand. The recommended approach is using the preparation scripts present in <a class="reference external" href="http://autodock.scripps.edu/resources/adt">AutoDockTools</a>. Although these tools are distributed on their own, and are only compatible with Python 2, we have prepared a <a class="reference external" href="https://github.com/jaimergp/autodocktools-prepare-py3k">Python 3-ready fork</a> containing the subset needed for protein
and ligand preparations. This should be enough for our needs.</p>


<h3 id="Binding-pocket-prediction">Binding pocket prediction<a class="headerlink" href="#Binding-pocket-prediction" title="Permalink to this headline">¶</a></h3>
<p>The docking calculation will work best if we perform it in a reasonably small search space, normally covering a single binding pocket. To guesstimate the best one, we can use DoGSiteScorer, available for free and online at Proteins.plus.</p>

<h4 id="Proteins.plus-DoGSiteScorer">Proteins.plus DoGSiteScorer<a class="headerlink" href="#Proteins.plus-DoGSiteScorer" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Role: Interactive web interface for several CADD tools</p></li>
<li><p>Website: <a class="reference external" href="http://proteins.plus">http://proteins.plus</a></p></li>
<li><p>API: Yes, REST-based. Simple enough to apply bare <code class="docutils literal notranslate"><span class="pre">requests</span></code></p></li>
<li><p>Documentation: <a class="reference external" href="https://proteins.plus/help/index">https://proteins.plus/help/index</a></p></li>
<li><p>Literature:</p>
<ul>
<li><p><a class="reference external" href="https://doi.org/10.1021/ci100241y">J. Chem. Inf. Model. (2010), 50, 11, 2041-2052</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1093/bioinformatics/bts310">Bioinformatics (2012), 28, 15, 2074–2075</a></p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>Automated prediction of protein active sites is essential for large-scale protein function prediction, classification, and druggability estimates. In this work, we present DoGSite, a new structure-based method to predict active sites in proteins based on a Difference of Gaussian (DoG) approach which originates from image processing. In contrast to existing methods, DoGSite splits predicted pockets into subpockets, revealing a refined description of the topology of active sites. DoGSite
correctly predicts binding pockets for over 92% of the PDBBind and the scPDB data set, being in line with the best-performing methods available. In 63% of the PDBBind data set the detected pockets can be subdivided into smaller subpockets. The cocrystallized ligand is contained in exactly one subpocket in 87% of the predictions. Furthermore, we introduce a more precise prediction performance measure by taking the pairwise ligand and pocket coverage into account. In 90% of the cases DoGSite
predicts a pocket that contains at least half of the ligand. In 70% of the cases additionally more than a quarter of the respective pocket itself is covered by the cocrystallized ligand. Consideration of subpockets produces an increase in coverage yielding a success rate of 83% for the latter measure.</p>
</div></blockquote>



<h3 id="Docking">Docking<a class="headerlink" href="#Docking" title="Permalink to this headline">¶</a></h3>
<p>There are a couple of webservices available online for free use: SwissDock and OPAL webservices (which includes AutoDock Vina).</p>

<h4 id="SwissDock">SwissDock<a class="headerlink" href="#SwissDock" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Role: Perform docking calculations</p></li>
<li><p>Website: <a class="reference external" href="http://www.swissdock.ch">http://www.swissdock.ch</a></p></li>
<li><p>API: Yes, SOAP-based. No official client, use <code class="docutils literal notranslate"><span class="pre">suds-community</span></code>.</p></li>
<li><p>Documentation: <a class="reference external" href="http://www.swissdock.ch/pages/soap_access">http://www.swissdock.ch/pages/soap_access</a></p></li>
<li><p>Literature:</p>
<ul>
<li><p><a class="reference external" href="https://academic.oup.com/nar/article/39/suppl_2/W270/2506492">Nucleic Acids Res. (2011), 39, W270-7.</a></p></li>
<li><p><a class="reference external" href="https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.21797">J Comput Chem. (2011), 32, 10, 2149-59</a></p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>SwissDock, a web service to predict the molecular interactions that may occur between a target protein and a small molecule. SwissDock is based on the docking software EADock DSS, whose algorithm consists of the following steps: 1. Many binding modes are generated either in a box (local docking) or in the vicinity of all target cavities (blind docking). 2. Simultaneously, their CHARMM energies are estimated on a grid. 3. The binding modes with the most favorable energies are evaluated with
FACTS, and clustered. 4. The most favorable clusters can be visualized online and downloaded on your computer.</p>
</div></blockquote>


<h4 id="OPAL-webservices">OPAL webservices<a class="headerlink" href="#OPAL-webservices" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Role: CADD as a service</p></li>
<li><p>Website: <a class="reference external" href="http://nbcr-222.ucsd.edu/opal2/dashboard">http://nbcr-222.ucsd.edu/opal2/dashboard</a></p></li>
<li><p>API: Yes, SOAP-based. No official client, use <code class="docutils literal notranslate"><span class="pre">suds-community</span></code>.</p></li>
<li><p>Documentation: <a class="reference external" href="http://nbcr-222.ucsd.edu/opal2/dashboard?command=docs">http://nbcr-222.ucsd.edu/opal2/dashboard?command=docs</a> (currently offline)</p></li>
<li><p>Literature:</p>
<ul>
<li><p>Manuscript: <a class="reference external" href="https://academic.oup.com/nar/article/38/suppl_2/W724/1122840">Nucleic Acids Res. (2010), 38, W724-31</a></p></li>
<li><p>Documentation: <a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.533.7960&amp;rep=rep1&amp;type=pdf">Opal: Simple Web Services Wrappers for Scientific Applications</a></p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>Biomedical applications have become increasingly complex, and they often require large-scale high-performance computing resources with a large number of processors and memory. The complexity of application deployment and the advances in cluster, grid and cloud computing require new modes of support for biomedical research. Scientific Software as a Service (sSaaS) enables scalable and transparent access to biomedical applications through simple standards-based Web interfaces. Towards this end,
we built a production web server (<a class="reference external" href="http://ws.nbcr.net">http://ws.nbcr.net</a>) in August 2007 to support the bioinformatics application called MEME. The server has grown since to include docking analysis with AutoDock and AutoDock Vina, electrostatic calculations using PDB2PQR and APBS, and off-target analysis using SMAP. All the applications on the servers are powered by Opal, a toolkit that allows users to wrap scientific applications easily as web services without any modification to the scientific codes, by
writing simple XML configuration files. Opal allows both web forms-based access and programmatic access of all our applications. The Opal toolkit currently supports SOAP-based Web service access to a number of popular applications from the National Biomedical Computation Resource (NBCR) and affiliated collaborative and service projects. In addition, Opal’s programmatic access capability allows our applications to be accessed through many workflow tools, including Vision, Kepler, Nimrod/K and
VisTrails. From mid-August 2007 to the end of 2009, we have successfully executed 239,814 jobs. The number of successfully executed jobs more than doubled from 205 to 411 per day between 2008 and 2009. The Opal-enabled service model is useful for a wide range of applications. It provides for interoperation with other applications with Web Service interfaces, and allows application developers to focus on the scientific tool and workflow development. Web server availability: <a class="reference external" href="http://ws.nbcr.net">http://ws.nbcr.net</a>.</p>
</div></blockquote>




<h2 id="Practice">Practice<a class="headerlink" href="#Practice" title="Permalink to this headline">¶</a></h2>

<h3 id="Get-files-from-part-A">Get files from part A<a class="headerlink" href="#Get-files-from-part-A" title="Permalink to this headline">¶</a></h3>
<p>First, we will define some variables pointing to the files we obtained in part A:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PROTEIN</span></code>: path to the <code class="docutils literal notranslate"><span class="pre">.mol2</span></code> file containing the structure of the target, without any ligands or ions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">COMPLEX</span></code>: path to the <code class="docutils literal notranslate"><span class="pre">.pdb</span></code> file containing the structure of the target AND the native ligand in its binding site</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SMILES_FILE</span></code>: path to the <code class="docutils literal notranslate"><span class="pre">.txt</span></code> file containing the SMILES representations for all the similar compounds found in PubChem</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">smiles</span></code>: list of the SMILES string contained in <code class="docutils literal notranslate"><span class="pre">SMILES_FILE</span></code></p></li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>PROTEIN = "data/protein.mol2"
COMPLEX = "data/complex.pdb"
SMILES_FILE = "data/similar_smiles.txt"
with open(SMILES_FILE) as f:
    smiles = [line.strip() for line in f]
</pre></div>
</div>
</div>


<h3 id="Use-SwissDock">Use SwissDock<a class="headerlink" href="#Use-SwissDock" title="Permalink to this headline">¶</a></h3>
<p>SwissDock uses a SOAP interface, so we will need to install <code class="docutils literal notranslate"><span class="pre">suds</span></code> for that.</p>
<blockquote>
<div><p>Notice: SwissDock servers are not working lately. Go to the OPAL alternative below!</p>
</div></blockquote>
!pip install suds-community<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>from suds.client import Client
import zlib
import string
import requests


def swissdock_client():
    # Server seems to be down at the moment...
    # http://swissdock.vital-it.ch/soap/ replies with 503 Unavailable
    # because it points to wrong domain... patch it?
    SWISSDOCK_WSDL_URL = "http://www.swissdock.ch/soap/wsdl"
    r = requests.get("http://www.swissdock.ch/soap/wsdl")
    r.raise_for_status()
    WSDL = r.text.replace("http://swissdock.vital-it.ch/soap/", "http://www.swissdock.ch/soap/")
    with open("data/swissdock.wsdl", "w") as f:
        f.write(WSDL)
    HERE = _dh[0]
    return Client(f"file://{HERE}/data/swissdock.wsdl")


def prepare_protein(client, protein):
    """
    Given a PDB file (string contents), returns PSF and CRD
    """
    encoded_protein = zlib.compress(protein.encode("utf-8"))
    job_id = client.service.prepareTarget(target=encoded_protein)
    while True:
        result = client.service.isTargetPrepared(jobID=job_id)
        if result is None:
            raise ValueError("No such a job present")
        if result in (False, "false", 0):
            time.sleep(5)
        else:  # ready!
            break
    protein_files = client.service.getPreparedTarget(job_id)
    if protein_files is None or len(protein_files) != 2:
        raise ValueError("Could not prepare protein!")
    return protein_files


def prepare_ligand(client, ligand):
    """
    Given a MOL2 file (string contents), returns PDB, RTF, PAR.

    Ligand must be protonated beforehand!
    """
    encoded_ligand = zlib.compress(ligand.encode("utf-8"))
    job_id = client.service.prepareLigand(ligand=encoded_ligand)
    while True:
        result = client.service.isLigandPrepared(jobID=job_id)
        if result is None:
            raise ValueError("No such a job present")
        if result in (False, "false", 0):
            time.sleep(5)
        else:  # ready!
            break
    ligand_files = client.service.getPreparedLigand(job_id)
    if ligand_files is None or len(ligand_files) != 3:
        raise ValueError("Could not prepare ligand!")
    return ligand_files


def dock(client, protein, ligand, name=None):
    protein_psf, protein_crd = prepare_protein(client, protein)
    ligand_pdb, ligand_rtf, ligand_par = prepare_ligand(client, ligand)

    if name is None:
        name = "teachopencadd" + "".join([random.choice(string.ascii_letters) for _ in range(5)])
    job_id = client.service.startDocking(
        protein_psf, protein_crd, ligand_pdb, [ligand_rtf], [ligand_par], name
    )
    if job_id in (None, "None"):
        raise ValueError("Docking job could not be submitted")
    while not client.service.isDockingTerminated(job_id):
        time.sleep(5)
    all_files = client.service.getPredictedDockingAllFiles(job_id)
    with open("docking_results.zip", "w") as f:
        f.write(all_files)
    target, docked = client.service.getPredictedDocking(job_id)
    client.service.forget(job_id)
    return target, docked


def smiles_to_pdb(s, out="output.pdb"):
    m = Chem.AddHs(Chem.MolFromSmiles(s))
    AllChem.EmbedMolecule(m)
    if out is None:
        return Chem.MolToPDBBlock(m)
    Chem.MolToPDBFile(m, out)
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>try:
    import Mol2Writer
except ImportError:
    # Ugly hack to get Mol2 writer/readers in RDKit
    import os
    working_dir = os.getcwd()
    os.chdir(_dh[0])
    !wget https://raw.githubusercontent.com/rdkit/rdkit/60081d31f45fa8d5e8cef527589264c57dce7c65/rdkit/Chem/Mol2Writer.py &gt; /dev/null
    os.chdir(working_dir)
    import Mol2Writer
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>def step_03_swissdock(protein_pdb, ligand_smiles):
    ligand = Chem.AddHs(Chem.MolFromSmiles(ligand_smiles))
    AllChem.EmbedMolecule(ligand)
    ligand_mol2 = Mol2Writer.MolToCommonMol2Block(ligand)
    client = swissdock_client()
    return dock(client, protein_pdb, ligand_mol2)
</pre></div>
</div>
</div>
<blockquote>
<div><p><em>The cell below has been disabled because SwissDock servers are currently unavailable. If you insist on running it, you will need to convert the protein mol2 to PDB first. You can use OpenBabel for that (installed in part C). Feel free to define a convenience</em> <code class="docutils literal notranslate"><span class="pre">mol2_to_pdb</span></code> <em>function.</em></p>
</div></blockquote>
# TODO: Convert from mol2 to pdb!
# protein_pdbblock = mol2_to_pdb(PROTEIN, out=None)
step_03_swissdock(protein_pdbblock, smiles[0])

<h3 id="Perform-docking-with-OPAL-webservices">Perform docking with OPAL webservices<a class="headerlink" href="#Perform-docking-with-OPAL-webservices" title="Permalink to this headline">¶</a></h3>
<p>SwissDock is not working recently, so we can resort to yet another webservice. The interface is a bit more rudimentary, but it should work. However, protein and ligand must be prepared locally with <code class="docutils literal notranslate"><span class="pre">AutoDockTools</span></code>. We have prepared a Python 3-ready fork, but it’s not well tested. It seems to work well enough for our purposes here, though.</p>
<p>You can install it with:</p>
!pip install https://github.com/jaimergp/autodocktools-prepare-py3k/archive/master.zip<p>The protocol for the docking calculation is the following:</p>
<ol class="arabic simple">
<li><p>Prepare the protein and the ligands with AutoDockTools (locally)</p></li>
<li><p>Find the best possible binding pocket with <a class="reference external" href="https://proteins.plus/2ozr#dogsite">Proteins.plus’ DoGSiteScorer</a>. We will use this information to configure the Vina calculation (geometric center and size of the search space)</p></li>
<li><p>Run the Vina calculation on OPAL</p></li>
</ol>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>import time
import os
from io import StringIO
</pre></div>
</div>
</div>

<h4 id="Prepare-the-structures">Prepare the structures<a class="headerlink" href="#Prepare-the-structures" title="Permalink to this headline">¶</a></h4>
<p>Preparing the structure simply involves running the appropriate parts of the <code class="docutils literal notranslate"><span class="pre">AutoDockTools</span></code> library:</p>
<ul class="simple">
<li><p>Reading the structure file with <code class="docutils literal notranslate"><span class="pre">MolKit</span></code></p></li>
<li><p>Applying the correct preparer: <code class="docutils literal notranslate"><span class="pre">AD4ReceptorPreparation</span></code> for the protein, <code class="docutils literal notranslate"><span class="pre">AD4LigandPreparation</span></code> for the ligand.</p></li>
</ul>
<p>The preparation itself will take care of things such as:</p>
<ul class="simple">
<li><p>Adding hydrogens to the protein and ligand</p></li>
<li><p>Removing strange residues that do not belong to the protein</p></li>
<li><p>Assigning atom types and partial charges</p></li>
<li><p>Recognizing torsionable branches in the ligand</p></li>
</ul>
<p>The results are written to disk as <code class="docutils literal notranslate"><span class="pre">PDBQT</span></code> files.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>######################
#
# Structure preparation
#
######################

import MolKit
from AutoDockTools.MoleculePreparation import (
    AD4ReceptorPreparation,
    AD4LigandPreparation,
)


def opal_prepare_protein(protein):
    """
    AutoDock expects PDBQT files
    """
    mol = MolKit.Read(protein)[0]
    mol.buildBondsByDistance()
    RPO = AD4ReceptorPreparation(mol, outputfilename=protein + ".pdbqt")
    return protein + ".pdbqt"


def opal_prepare_ligand(ligand):
    """
    AutoDock expects PDBQT files
    """
    mol = MolKit.Read(ligand)[0]
    mol.buildBondsByDistance()
    RPO = AD4LigandPreparation(mol, outputfilename=ligand + ".pdbqt")
    return ligand + ".pdbqt"
</pre></div>
</div>
</div>


<h4 id="Guess-the-binding-sites">Guess the binding sites<a class="headerlink" href="#Guess-the-binding-sites" title="Permalink to this headline">¶</a></h4>
<p>The DoGSiteScorer installation present in Proteins.plus provides a REST API that is very easy to use, if you only need to process a protein present in the PDB database (see <code class="docutils literal notranslate"><span class="pre">dogsite_scorer_submit_with_pdbid</span></code>). However, since we are using structures provided by KLIFS, we cannot guarantee that the position and orientation of the structure present in the official PDB registries match the one present in KLIFS. Although we could superpose both and then apply the resulting transformation matrix to
the obtained pockets, it would be easier to simply upload our PDB file to Proteins.plus, as provided in the standard web interface.</p>
<p>However, the REST API does not provide such an option, so we have to reverse engineer the process. To locate the appropriate HTTP requests, you would need to open the Network tab in the Chrome Developer Tools and start writing down which requests were performed as you use the website normally. Authenticity tokens and HTTP headers are key to obtain a valid request here!</p>
<p>The results of this research are consolidated in the <code class="docutils literal notranslate"><span class="pre">dogsite_scorer_submit_with_custom_pdb</span></code> function. If you are interested in the technical details, read through the comments in the function.</p>
<blockquote>
<div><p>For this approach, you will also need <code class="docutils literal notranslate"><span class="pre">BeautifulSoup</span></code> to parse some HTML code during the binding site guessing:</p>
</div></blockquote>
!pip install BeautifulSoup4<p>With this method we can now obtain the geometric center of the most probable binding pocket, as well as its size. Both values are needed to configure the Vina calculation.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>######################
#
# Guess binding pocket
#
######################

from bs4 import BeautifulSoup
import requests


def dogsite_scorer_submit_with_pdbid(pdbid, chain):
    """
    This is the official API, but they only allow PDB codes

    Parameters
    ----------
    pdbid : str
        4-letter PDB identifier
    chain : str
        Structure chain to be analyzed

    Returns
    -------
    str
        URL that can be queried to get updates on whether the job is running or finished
    """
    # Submit job to Proteins.plus
    r = requests.post(
        "https://proteins.plus/api/dogsite_rest",
        json={
            "dogsite": {
                "pdbCode": pdbid,
                "analysisDetail": "1",
                "bindingSitePredictionGranularity": "1",
                "ligand": "",
                "chain": chain,
            }
        },
        headers={"Content-type": "application/json", "Accept": "application/json",},
    )

    r.raise_for_status()
    # We have to query location for updates on the calculation
    return r.json()["location"]


def dogsite_scorer_submit_with_custom_pdb(pdbfile):
    """
    In order to upload a custom PDB, we have to mimic the actual HTML frontend:

    1. Obtain the CSRF token out the HTML meta headers
    2. Post the file to upload it
    3. The returned HTML page will contain the URL ID, which in turn will allow
       us to obtain the internal shorthand job ID. We can use that one to
       retrieve the public job API ID by mimicking the async calls that the
       webserver performs in the frontend (as if we were using the web interface).
    4. Once we obtain the public job ID we can switch to using the REST API.
    """
    # We need to use a `session` to store intermediate cookies during the process
    session = requests.Session()
    r = session.get("https://proteins.plus/")
    r.raise_for_status()
    # The homepage contains the CSRF token needed to validate our request
    # Otherwise it wouldn't be safe! We have to use that throughout our requests
    # so the best way is to set it as part of the session HTTP headers
    html = BeautifulSoup(r.text)
    token = html.find("input", {"name": "authenticity_token"}).attrs["value"]
    session.headers["X-CSRF-Token"] = token

    # 1. Upload file
    with open(pdbfile, "rb") as f:
        r = session.post("https://proteins.plus", files={"pdb_file[pathvar]": f})
    r.raise_for_status()

    # If the REST API supported file uploads, we would have the public ID already
    # but in the meantime you will have to work around it this way

    # 2. Get internal location id
    html = BeautifulSoup(r.text)
    pdb_id = html.find("input", {"name": "dogsite[pdbCode]"}).attrs["value"]

    # 3. Get the internal job ID
    session.headers["Referer"] = "https://proteins.plus" + pdb_id
    r = session.post(
        f"https://proteins.plus/{pdb_id}/dogsites",
        json={"dogsite": {"pdbCode": pdb_id}},
        headers={"Content-type": "application/json", "Accept": "application/json",},
    )
    r.raise_for_status()
    job_id = r.json()["job_id"]
    time.sleep(3)  # wait a bit before continuing so the server can process the request

    # 4. Get the public job ID
    while True:
        r = session.get(
            f"https://proteins.plus/{pdb_id}/dogsites/{job_id}?_={round(time.time())}",
            headers={
                "Accept": "application/json, text/javascript, */*",
                "Sec-Fetch-Mode": "cors",
                "Sec-Fetch-Site": "same-origin",
                # this line below makes all the difference, apparently
                # otherwise, error 406 is thrown
                "X-Requested-With": "XMLHttpRequest",
            },
        )
        r.raise_for_status()
        if "Calculation in progress..." in r.text:  # not finished yet
            time.sleep(5)
            continue
        if "Error during DogSiteScorer calculation" in r.text:  # malformed file?
            raise ValueError("Could not run DoGSiteScorer!")
        break

    results_id = None
    for lines in r.text.splitlines():
        for line in lines.split("\\n"):
            if "results/dogsite" in line:
                results_id = line.split("/")[3]
                break
    if results_id is None:
        raise ValueError(r.text)

    return f"https://proteins.plus/api/dogsite_rest/{results_id}"


def dogsite_scorer_guess_binding_site(protein):
    """
    Use Proteins.plus' DoGSiteScorer to retrieve most probable binding site in protein.
    """
    if len(protein) == 4:  # pdb code
        job_location = dogsite_scorer_submit_with_pdbid(protein)
    elif protein.endswith(".pdb"):
        job_location = dogsite_scorer_submit_with_custom_pdb(protein)
    else:
        raise ValueError("`protein` must be a PDB ID or a path to a .pdb file!")

    # Check when the calculation has finished
    while True:
        result = requests.get(job_location)
        result.raise_for_status()  # if it fails, it will stop here
        if result.status_code == 202:  # still running
            time.sleep(5)
            continue
        break

    # The residues files contain the geometric center and radius as a comment in the PDB file
    # first file (residues[0]) is the best scored pocket
    pdb_residues = requests.get(result.json()["residues"][0]).text
    for line in pdb_residues.splitlines():
        line = line.strip()
        if line.startswith("HEADER") and "Geometric pocket center at" in line:
            fields = line.split()
            center = [float(x) for x in fields[5:8]]
            radius = float(fields[-1])
            break
    return center, radius  # this is what we need for our Vina calculation
</pre></div>
</div>
</div>


<h4 id="Run-Vina-on-OPAL">Run Vina on OPAL<a class="headerlink" href="#Run-Vina-on-OPAL" title="Permalink to this headline">¶</a></h4>
<p>Once we have (1) prepared the protein and ligand, and (2) guessed the search area, we can submit the actual calculation to the OPAL web servers. This involves:</p>
<ol class="arabic simple">
<li><p>Initializing the SOAP client with <code class="docutils literal notranslate"><span class="pre">suds</span></code></p></li>
<li><p>Encoding the files as <code class="docutils literal notranslate"><span class="pre">`base64</span></code> strings &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Base64#Examples">https://en.wikipedia.org/wiki/Base64#Examples</a>&gt;`__ so they can be attached to the SOAP XML request</p></li>
<li><p>Submitting the job request and getting the job ID back</p></li>
<li><p>Querying the server with the job ID to check whether the calculation is finished or not</p></li>
<li><p>Downloading the relevant output files with <code class="docutils literal notranslate"><span class="pre">requests</span></code></p></li>
</ol>
<blockquote>
<div><p>These steps are not very well documented in the OPAL website (actually, the documentation is <a class="reference external" href="http://rocce-vm0.ucsd.edu/data/docs/opal/documentation.html">unavailable</a>), so they were figured out by exploring the source code present in some of the <a class="reference external" href="http://plato.cgl.ucsf.edu/trac/chimera/browser/trunk/libs/WebServices/opal_client.py">UCSF Chimera modules</a> that rely on these servers.</p>
</div></blockquote>
<p>Since the calculation usually takes 5-15 minutes, for the 4th step we will use some of the Jupyter goodies and update the contents of the output file in realtime (see function <code class="docutils literal notranslate"><span class="pre">iprint()</span></code>). That way, we can check the progress instead of blindly trusting that the calculation is running ok!</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>######################
#
# Run calculation
#
######################

from suds.client import Client
from IPython.display import display, clear_output, HTML
from rdkit import Chem
from rdkit.Chem import AllChem

VINA_CONFIG = """
center_x = {center[0]}
center_y = {center[1]}
center_z = {center[2]}
size_x = {size[0]}
size_y = {size[1]}
size_z = {size[2]}
"""


def opal_run_docking(protein, ligand, center, size, stream_output=True):
    """
    Connect to OPAL webservices and submit job
    """
    client = Client("http://nbcr-222.ucsd.edu/opal2/services/vina_1.1.2?wsdl")
    files = "receptor.pdbqt", "ligand.pdbqt", "vina.conf"
    with open(protein) as f:
        protein_contents = f.read()
    with open(ligand) as f:
        ligand_contents = f.read()
    file_map = [
        {"name": "receptor.pdbqt", "contents": base64ify(protein_contents)},
        {"name": "ligand.pdbqt", "contents": base64ify(ligand_contents)},
        {
            "name": "vina.conf",
            "contents": base64ify(VINA_CONFIG.format(center=center, size=size)),
        },
        {"name": "results.pdbqt", "contents": ""},
    ]
    cli_args = (
        "--receptor receptor.pdbqt --ligand ligand.pdbqt --config vina.conf --out results.pdbqt"
    )

    response = client.service.launchJob(cli_args, inputFile=file_map)
    job_id = response.jobID
    url = f"http://nbcr-222.ucsd.edu/opal-jobs/{job_id}"
    message = "Waiting for job " + url
    while True:
        r = requests.get(url + "/vina.out")
        try:
            r.raise_for_status()
        except:  # output file might not exist yet during the first checks
            iprint(message)
        else:
            iprint(f"{message}\n{r.text}")
        if client.service.queryStatus(job_id).code == 2:
            time.sleep(10)
            continue
        print("\nFinished!")
        break

    output_response = client.service.getOutputs(job_id)
    output_files = {
        "stdout.txt": requests.get(output_response.stdOut).text,
        "stderr.txt": requests.get(output_response.stdErr).text,
    }
    for f in output_response.outputFile:
        if f.name in files:
            continue
        r = requests.get(f.url)
        r.encoding = "utf-8"
        r.raise_for_status()
        contents = r.text
        output_files[f.name] = contents
        time.sleep(0.1)

    return output_files


######################
#
# Utilities
#
######################

import base64


def base64ify(bytes_or_str):
    """
    Mimic Py2k base64encode behavior
    """
    if isinstance(bytes_or_str, str):
        input_bytes = bytes_or_str.encode("utf8")
    else:
        input_bytes = bytes_or_str

    output_bytes = base64.urlsafe_b64encode(input_bytes)
    return output_bytes.decode("ascii")


def iprint(s):
    """
    We can use this function to print outputs, overwriting previous ones, so it
    looks like it's constantly updating :)
    """
    clear_output(wait=True)
    s = s.replace("\n", "&lt;br /&gt;")
    display(HTML(f"&lt;pre&gt;{s}&lt;/pre&gt;"))
</pre></div>
</div>
</div>


<h4 id="Put-it-all-together">Put it all together<a class="headerlink" href="#Put-it-all-together" title="Permalink to this headline">¶</a></h4>
<p>Now that all the needed functions are defined, we can create the pipeline:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span>def step_03_opal(protein, smiles, pdbcomplex):
    """
    Given a protein structure and a list of smiles strings:
    Steps:
        1. Prepare the protein for AutoDock Vina (locally)
        2. Use DoGSiteScorer to find the most probable binding site
        3. For each ligand, use RDKit to write a 3D PDB file and
           run AutoDockVina on OPAL

    The whole thing should take around 5-15 mins

    The result is a dictionary with the output file contents. We
    are mainly interested in result['results.pdbqt']
    """
    prepared_protein = opal_prepare_protein(protein)
    center, radius = dogsite_scorer_guess_binding_site(pdbcomplex)
    size = [radius] * 3  # Vina supports non-cubic boxes, but we will use a cube for simplicity
    for i, smile in enumerate(smiles):
        smiles_to_pdb(smile, f"data/ligand{i}.pdb")
        prepared_ligand = opal_prepare_ligand(f"data/ligand{i}.pdb")
        result = opal_run_docking(prepared_protein, prepared_ligand, center, size)
    return result
</pre></div>
</div>
</div>
<p>Run it! <code class="docutils literal notranslate"><span class="pre">%time</span></code> magic will measure how long it takes for us.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-none notranslate"><div class="highlight"><pre>
<span></span># We will only process the first ligand in `smiles`
%time result = step_03_opal(PROTEIN, smiles[:1], COMPLEX)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<pre>Waiting for job http://nbcr-222.ucsd.edu/opal-jobs/appvina_1.1.21569479512106-161978933<br/>#################################################################<br/># If you used AutoDock Vina in your work, please cite:          #<br/>#                                                               #<br/># O. Trott, A. J. Olson,                                        #<br/># AutoDock Vina: improving the speed and accuracy of docking    #<br/># with a new scoring function, efficient optimization and       #<br/># multithreading, Journal of Computational Chemistry 31 (2010)  #<br/># 455-461                                                       #<br/>#                                                               #<br/># DOI 10.1002/jcc.21334                                         #<br/>#                                                               #<br/># Please see http://vina.scripps.edu for more information.      #<br/>#################################################################<br/><br/>Reading input ... done.<br/>Setting up the scoring function ... done.<br/>Analyzing the binding site ... done.<br/>Using random seed: -1816910541<br/>Performing search ... <br/>0%   10   20   30   40   50   60   70   80   90   100%<br/>|----|----|----|----|----|----|----|----|----|----|<br/>***************************************************<br/>done.<br/>Refining results ... done.<br/><br/>mode |   affinity | dist from best mode<br/>     | (kcal/mol) | rmsd l.b.| rmsd u.b.<br/>-----+------------+----------+----------<br/>   1         -8.4      0.000      0.000<br/>Writing output ... done.<br/></pre></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>

Finished!
CPU times: user 2.85 s, sys: 289 ms, total: 3.14 s
Wall time: 5min 25s
</pre></div></div>
</div>


<h4 id="Understanding-the-output">Understanding the output<a class="headerlink" href="#Understanding-the-output" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">result</span></code> is a dictionary with several keys, corresponding to the output files and their text contents. We are mainly interested in:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">results.pdbqt</span></code> contains the docked ligands. It’s a modified multi-model PDB file. Since we kept the protein rigid, we just need to open each ligand model together with the original protein structure.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vina.out</span></code> is the text output you see above. It will provide the table-like information.</p></li>
</ul>
<p>Save them to disk so we can retrieve them later.</p>
with open('data/results.pdbqt', 'w') as f:
    f.write(result['results.pdbqt'])
with open('data/vina.out', 'w') as f:
    f.write(result['vina.out'])


<h3 id="Visualize-docking-results">Visualize docking results<a class="headerlink" href="#Visualize-docking-results" title="Permalink to this headline">¶</a></h3>
<p>Once the calculation has run and the files have been downloaded, it’s time to visualize them! You will see how to do that in part C.</p>



<h2 id="Discussion">Discussion<a class="headerlink" href="#Discussion" title="Permalink to this headline">¶</a></h2>
<p>OPAL offers a Vina installation to perform docking calculations for free, but we have to prepare the input files locally before the submission. Part of that preparation involves defining the search area, normally around a known binding site. Instead of guessing visually, we have used the DoGSiteScorer server present in Proteins.plus to calculate the origin and radius of the most probable binding site. These two services used different communication interfaces.</p>
<p>Proteins.plus uses REST, but does not provide a <code class="docutils literal notranslate"><span class="pre">swagger.json</span></code> definition as KLIFS did, so we had to build our own requests manually. Fortunately, the service is simple enough to <em>only</em> need a couple of requests… or so we thought! The current API does not allow for custom PDB uploads, so we had to use a handful of GET and POST requests to pretend we were using a normal browser. To guess the correct requests, the Network tab in Chrome Developer Tools was really handy. If you ever need to
reverse engineer a webservice, this is one of the tools you can use!</p>
<p>OPAL is built with the XML-based SOAP standard, a bit more cumbersome than JSON-based REST, but <code class="docutils literal notranslate"><span class="pre">suds</span></code> makes it really easy. Although <code class="docutils literal notranslate"><span class="pre">suds</span></code> will report the available methods, these are not very well documented. Fortunately, there are some code examples scattered in some modules of <a class="reference external" href="http://plato.cgl.ucsf.edu/trac/chimera/browser/trunk/libs/WebServices/opal_client.py">UCSF Chimera</a>. Jobs submitted to OPAL are public once you have the job ID and the files are updated in realtime, so we
could build a live preview of the calculation output by querying the server every N seconds and updating the <code class="docutils literal notranslate"><span class="pre">display()</span></code>ed HTML dynamically. This trick can also be used to query a calculation happening in your machine: all you need to do is read the file contents, clear the current output and display the new one as an <code class="docutils literal notranslate"><span class="pre">HTML()</span></code> object (see function <code class="docutils literal notranslate"><span class="pre">iprint()</span></code>).</p>


<h2 id="Quiz">Quiz<a class="headerlink" href="#Quiz" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>How can you tell if the docking has run successfully in the remote server?</p></li>
<li><p>Why do we need to prepare the AutoDock Vina input files locally?</p></li>
<li><p>Advanced: Can you find the correct HTTP requests to use <a class="reference external" href="https://mcule.com/apps/1-click-docking/">MCule’s docking server</a> from the Notebook?</p></li>
</ul>




          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
            <a href="012_query_pubchem.html" title="Structure-based CADD using online APIs/servers"
               class="md-flex md-footer-nav__link md-footer-nav__link--prev"
               rel="prev">
              <div class="md-flex__cell md-flex__cell--shrink">
                <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
              </div>
              <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
                <span class="md-flex__ellipsis">
                  <span
                      class="md-footer-nav__direction"> Previous </span> Structure-based CADD using online APIs/servers </span>
              </div>
            </a>
          
          
            <a href="016_protein_ligand_interactions.html" title="Structure-based CADD using online APIs/servers"
               class="md-flex md-footer-nav__link md-footer-nav__link--next"
               rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span
                class="md-flex__ellipsis"> <span
                class="md-footer-nav__direction"> Next </span> Structure-based CADD using online APIs/servers </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink"><i
                class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2018-2020, Volkamer Lab. Project structure based on the Computational Molecular Science Python Cookiecutter version 1.1.
              
          </div>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 3.3.0.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>